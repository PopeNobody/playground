#!/usr/bin/perl
# vim: ts=2 sw=2 ft=perl
eval 'exec perl -x -wS $0 ${1+"$@"}'
  if 0;
$|++;
use FindBin qw($Bin);
use Path::Tiny;
open(STDOUT,">&STDERR");
BEGIN {
  for(map { "$_" } $Bin) {
    s{/s?bin$}{};
    $FindBin::prefix="$_";
  };    
};
BEGIN {
  use lib $FindBin::prefix."/lib";
};
use common::sense;
#use autodie;
use Nobody::Util;
use Snatcher;
our(@VERSION) = qw( 0 1 0 );
use AI::Conv;
use AI::Transact qw(transact);
use DryRun;
sub next;
my ($conv,$convf);
($convf)=(@ARGV ? shift : "dat/dry-run/conv.jwrap");
my ($base)="dat/dry-run/conv";
$convf=path($convf);
$conv=AI::Conv->new(path("$convf"));
my $i;
for($i=1000;$i<9999;++$i)
{
  next if -e "$base.$i.jwrap";
  system("cp", "$base.jwrap", "$base.$i.jwrap");
  last;
};
ddx($conv);

my ($msg) = DryRun::next();
$msg=AI::Msg->new($msg);
$conv->add($msg);
ddx($conv);

__DATA__
for($data->[$idx++]) {
  $conv->add(AI::Msg->new($_->{role},$_->{name},$_->{text}));
  $conv=$conv->new($conv->file);
  ddx($conv);
};
ddx( { idx=>$idx } );
unshift(@$data,++$idx);
spit("$base-text.pl",Dumper(@$data));
use Data::Dumper;
$Data::Dumper::Terse=1;
