#!/usr/bin/perl
# vim: ts=2 sw=2 ft=perl
eval 'exec perl -x -wS $0 ${1+"$@"}'
  if 0;
BEGIN { open(STDIN,"</dev/tty"); open(STDOUT,">/dev/tty"); open(STDERR,">&STDOUT"); };
  our(@VERSION) = qw( 0 1 0 );
$|++;
use AnyEvent;
my ($agent)=Agent->new();
Agent->note("calling recv, then will exit");
$agent->{covar}->recv;
exit(0);
package Agent;
use common::sense;
use FindLib qw(AI::Util);
use Carp qw(verbose);
use autodie;
use AI::Config qw(get_api_mod get_api_ua);
use AI::Conv;
use AI::UI;
use AI::Util;
use AnyEvent::Socket;
use AnyEvent::Handle;
use AnyEvent::Log;
use AnyEvent;
use AE;
sub note {
  say STDERR "note: => @_";
};
sub new(@) {
  my ($class,%self)=@_;
  my ($self)=\%self;
  note info=> "created new instance";
  $self{timer} = AnyEvent->timer(
    after=>60-time%60,
    interval=>60, cb=>sub { note(serdate); });
  $self{covar} //= AE::cv;
  $self{model} //= get_api_mod;
  $self{agent} //= do {
    my $agent=get_api_ua;
    die "Session not configured" unless defined($agent);
    $agent
  };
  ($self{port}) //= do {
    local(@_) = map { split } qx( id -u );
    ddx( "id returned: @_" );
    shift;
  };
  $self{port}+=1000 while $self{port}<4000;
  note "creating  tcp server\n";
  ddx ($self{serv});
  $self{serv} //= tcp_server $self{host}, $self{port}, sub {
    my ($fh, $host, $port) = @_;
    ddx( "entering sub: ($fh,$host,$port)\n" );
    ddx( fd => fileno($fh) );
    syswrite($fh,"This is a test, this is only a test!\n\n");
    ddx( fh=>$fh );
    my $hand;
    my $num;
    my $toggle;
    $hand = new AnyEvent::Handle (
      fh=>$fh,
      on_read => sub {
        local(@_)=@_;
        note( {on_read=>\@_} );
        my $rbuf=$hand->{rbuf};
        note( {length=>length($rbuf) });
        my $part=substr($hand->rbuf,0,length($hand->{rbuf}),"");
        note( {part=>length($part), rbuf=>length($hand->{rbuf}) } );
      },
      on_error => sub {
        local(@_)=@_;
        note( {on_error=>\@_} );
      },
      on_eof => sub {
        local(@_)=@_;
        note( {on_eof=>\@_} );
      },
      on_rtimeout => sub {
        local(@_)=@_;
        note( {on_eof=>\@_} );
      },
      on_wtimeout => sub {
        local(@_)=@_;
        note( {on_eof=>\@_} );
      },
      on_timeout => sub {
        local(@_)=@_;
        note( {on_eof=>\@_} );
      },
      read_size => 1024*1024,
    );
  };


  bless($self,$class);
};
sub url() {
  my ($self)=shift;
  my ($httpd)=$self->{httpd};
  "http://".($httpd->host).":".($httpd->port)."/";
};
