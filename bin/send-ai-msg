#!/usr/bin/perl
# vim: ts=2 sw=2 ft=perl
eval 'exec perl -x -wS $0 ${1+"$@"}'
  if 0;
$|++;
use FindBin qw($Dir);
use lib "$Dir/..:$Dir/../lib";
use common::sense;
use autodie;
our(@VERSION) = qw( 0 1 0 );
use HTTP::Tiny;
use IO::Socket;
use JSON::PP;
use Carp;
use Carp qw(verbose);
use AI::Util;
open(STDOUT,">&STDERR");
use Scalar::Util qw(reftype);
use Data::Dumper::Concise;

if( @ARGV==0 && -t 0 ) {
  system("vi etc/prompt.txt </dev/tty >/dev/tty");
  die "vi failed" if $?;
  @ARGV=qw(etc/prompt.txt);
};
open(STDIN,"<$ARGV[0]") if @ARGV;
if( defined($ENV{AI_PREFIX}) ){
  local(@_)=grep { s{^$ENV{AI_PREFIX}_API}{API} } keys %ENV;
  $ENV{$_}=$ENV{"$ENV{AI_PREFIX}_$_"} for @_;
};
for(grep { m{/_API_/} } keys %ENV) {
  delete $ENV{$_}; 
};
my ($content);
{
  package req;
  our($req)=
  {
    'method'=>'POST',
    'url' => "$ENV{API_URL}/chat/completions",
    headers=>{
      'content-type' => 'application/json',
      'authorization' => "Bearer $ENV{API_KEY}",
      'user-agent' => 'curl/7.88.1',
    },
    'content' => {
      "messages"=> [],
      "model"=> "$ENV{API_MOD}",
      "temperature"=> 0.7,
    }
  };
  sub ddx;
  *ddx=*main::ddx;
  sub reftype;
  *reftype=*main::reftype;
  sub model {
    my ($self)=@_;
    ddx($self);
    my ($model)=($self)->{content};
    main::ddx($model);
    main::ddx(main::reftype($model));
    $model;
  }
  bless($req,'req');
  sub main::req {
    bless($req, 'req');
  };
};
sub mk_msg($$) {
  my ($role,$content)=@_;
  croak "no role" unless defined ($role);
  croak "no content" unless defined ($content);
  my(%msg);
  $msg{role}=$role;
  $msg{content}=text_wrap($content);
  return \%msg;
};
my ($tiny)= HTTP::Tiny->new(default_headers=>req->{headers});
while(1) {
  {
    local(*_)=req->{content}{messages};
    push(@_, mk_msg("system",path("etc/system-msg.md")->slurp));
    local($_)=join("",<STDIN>);
    push(@_, mk_msg("user",$_));
  }

  path("req.txt")->spew(pp(req));
  my ($res)=$tiny->request(
    req->{method},
    req->{url},
    {
      content=>encode_json(req->{content})
    }
  );
  path("res.txt")->spew(pp($res));
  die "Failed: $res->{status} $res->{reason}\n" unless $res->{success};
  say "Status: ", $res->{status};
  say "Reason: ", $res->{reason};
  my ($cont)=decode_json($res->{content});
  path("cont.txt")->spew(pp($cont));
  my ($choices)=$cont->{choices};
  my (@choices)=@{$cont->{choices}};
  for(@choices) {
    $_=mk_msg("assistent",$_->{message}{content});
  }
  sub show_choice($$) {
    my($pfix)=shift;
    for(shift) {
      say $pfix, $_ for split( m{\n},$_->{content} );
    };
  };
  sub check_script {
    local(*_)=shift;
    my (@bt) = grep { $_[$_] =~ m{^```} } 0 .. @_;
    ddx(\@bt);  
  };
  if(@choices==0) {
    die "no coices in response";
  } else {
    # for now we only deal wtih chocie 0.
    maybe_run_script($choices[0]->{content});
  };
};
#      open(my $save,">&STDOUT");
#      open(STDOUT,"|tee -a etc/prompt.txt");
#      say "GROK:";
#      show_choice("  ",$choices[0]);
#      close(STDOUT);
#      for("\n".$choices[0]->content."\n"){
#        my (@parts) = split(m{\n```});
#        ddx(
#      };
#      open(STDOUT,">&".fileno($save));
#      open(STDOUT,"|tee script.pl");
#      show_choice("",$choices[0]);
#    } else {
#      my ($i)=0;
#      for( @{$cont->{choices}} ) {
#        say "  choice #", $i;
#        show_choice("    ",$_);
#      }
};
close(STDOUT);
